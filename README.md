# Заметки про базы данных

## Транзакции 

#### Вопросы
1. Понятие и свойства транзакицй;
2. Управление транзакциями в JPA;
3. Уровни изоляций транзакий;
4. Стратегии блокировки;
5. Бизнес-трнзакции.

### Понятие и свойства транзакицй

**Транзакция** - это ограниченный набор действий, с явно определенными начальной и завершающей операцией, который либо выполняется целиком, либо не выполняется вовсе.

**Свойства транзакций (ACID)**: 
1. Atomicity (атомарность) - в контексте набора действий выполняются либо все действия, либо ни одного;
2. Consistency (согласованность) - системные ресурсы должны пребывать в целостном и не противоречивом состоянии, транзакция не должна ничего испортить;
3. Isolation (изолированность) - до момента фиксаций одной транзакции, данные не должны быть доступны другим для изменения;
4. Durability (устойчивость) - результат выполнения транзакции не должен быть утрачен ни при каких обстоятельствах. То есть, транзакция завершилась - данные изменились и никак иначе.


Эти свойства могут настраиваться. 
Чаще всего настраивается Isolation. 

### Анамалии транзакций
 
 Настраиваются изменением уровня изоляции. 
1. Потерянные изменеия - при отсутствии уровня изоляции
![Потерянные изменеия](./images/потерянные_изменения.png)

Две транзакции одновременно читают, потом пишет одна, затем вторая, изменения первой теряются.

2. Грязное чтение - когда транзакция начинает читать данные, которые не были подтверждены предыдущей.
![Грязное чтение](./images/грязное_чтение.png)

Первая транзакция обновляет данные. Если при этом она разрешает читать данные другой, то вторая читает. При этом, первая
решила откатить изменения назад. А вторая прочитала уже то, что называется "грязные данные". 

3. Неповторяемое чтение - первая транзакция читает, вторая читает и сразу же меняет, первая транзакция еще раз читает и 
получает уже другие (измененные второй транзакцией) данные.
![Неповторяемое чтение](./images/неповторяемое_чтение.png)

4. Фантомная вставка. 
 
Пусть имеется две транзакции. 
![Фантомная вставка](./images/фантомная_вставка.png)

В транзакции 2 выполняется SQL-оператор, использующий все значения поля f2.
Затем в транзакции 1 выполняется вставка новой строки, приводящая к тому, что повторное выполнение 
SQL-оператора в транзакции 2 выдаст другой результат. 
Такая ситуация называется фантомной вставкой и является частным случаем неповторяющегося чтения. 
При этом, если выполняемый SQL-оператор выбирает не все значения поля f2, а только значение одной строки 
таблицы (используется предикат WHERE ), то выполнение оператора INSERT не приведет к ситуации фантомной вставки.
 
Типичный пример - внезапно поменялась цена товара на сайте. 

### Уровни исоляций транзакций

![Уровни исоляций транзакций](./images/уровни_изоляций_транзакций.png)

1. READ UNCOMMITTED (чтение нефиксированных данных) - тут проверяется только то, что не изменяются измененные
ранее данные. То есть, гарантия отсутствия потери обновлений;

2. READ COMMITTED - (по умолчанию в Postgres) защищает от "грязного чтения". 
Данные обновятся внутри какой либо открытой на чтение транзакции
тогда и только тогда, когда в другой транзакции произойдет фиксация изменений. 
Потому read committed - чтение только фиксированных данных.
Посути, SELECT увидит снимок базы данных. Однако, в данном режиме можно видеть незафиксированные именно в текущей транзакции
изменения. К тому же, два одинаковых селекта подряд могут дать разный результат в рамках одной транзакции, если в момент
между выполнениями этих селектов в другой транзакции произойдет фиксация. 

3. REPEATABLE READ - как правило, идет по умолчанию в MySQL, 
Уровень, при котором читающая транзакция «не видит» изменения данных, которые были ею ранее прочитаны.
При этом никакая другая транзакция не может изменять данные, читаемые текущей транзакцией (блокировка строки), 
пока та не окончена. Но вставлять строки можно, что не защищает от фантомного чтения.

4. SERIALIZABLE - блокирует доступ к таблице пока над ней совершаются операции.

Уровень изоляции может быть настроен как на всю базу, так и на каждую отдельную транзакцию.

### Стратегии блокировок

**Блокировка** - это метка о захвате объекта транзакцией в ограниченный или исключительный доступ с целью предотвращения
коллизий и поддержания целостности данных.

В многопользовательской среде предусмотрены две модели обновления данных в базе данных: 
оптимистичный параллелизм и пессимистичный параллелизм. 

**Пессимистическая** блокировка накладывается перед предполагаемой модификацией данных на все строки, 
которые такая модификация предположительно затрагивает. Во время действия такой блокировки исключена
модификация данных из сторонних сессий, данные из блокированных строк доступны согласно уровню изолированности транзакции. 
По завершению предполагаемой модификации гарантируется непротиворечивая запись результатов.

При выполнении команды SELECT...FOR UPDATE Oracle автоматически блокирует все строки, определяемые командой SELECT. 
Никто другой не сможет изменять эти строки до тех пор, пока не будет выполнена команда ROLLBACK или COMMIT, 
хотя другие сеансы по-прежнему могут читать из них данные.

**Оптимистическая** блокировка не ограничивает модификацию обрабатываемых данных сторонними сессиями, 
однако перед началом предполагаемой модификации запрашивает значение некоторого выделенного атрибута каждой из строк
данных (обычно используется наименование VERSION и целочисленный тип с начальным значением 0). Перед записью 
модификаций в базу данных перепроверяется значение выделенного атрибута, и если оно изменилось, то транзакция 
откатывается или применяются различные схемы разрешения коллизий. Если значение выделенного атрибута не изменилось 
— производится фиксация модификаций с одновременным изменением значения выделенного атрибута (например, инкрементом) 
для сигнализации другим сессиям о том, что данные изменились.

### Бизнес транзакции (conversation transactions)

Пример. Большая форма на сайте в несколько страниц/диалоговых окон/шагов. К каждому экрану пользователь может 
вернуться через час, через два и т.д.   

В Hibernate есть настройка, позволяющая сохранять такие транзакции между запросами. 

```java
session.setFlushMode(MANUAL);

// вносить изменения окончательно так
session.flush();
```

То есть, то что коммитится - в базу не попадает. Хранится в сессии. 

Материал взят из [этой лекции](https://www.youtube.com/watch?v=4PKZRQAtf38)

Материал по теме: 

1. https://habr.com/ru/post/317884/
2. https://habr.com/ru/post/135217/
3. https://www.youtube.com/watch?v=xIQLl374Xkg
4. https://docs.microsoft.com/ru-ru/dotnet/framework/data/adonet/transactions-and-concurrency